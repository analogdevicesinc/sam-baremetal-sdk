/*
 * Copyright (c) 2018 Analog Devices, Inc.  All rights reserved.
 *
 * Bare-Metal ("BM") device driver for A2B.  This driver provides basic support for the
 * AD2425W chip on the SHARC Audio Module board as well as the automotive extender board.
 *
 */
#include "bm_ad2425w.h"

/**
 * @brief      This is the IRQ opin call back for the AD2425 driver
 *
 * @param      ad2425w is the driver instance passed to the callback by the interrupt system
 */
BM_AD2425W_RESULT ad2425w_irq_callback(void *irq_arg) {

    // Cast pointer to instance of ad2425 driver associated with this interrupt
    BM_AD2425W_CONTROLLER *ad2425w = (BM_AD2425W_CONTROLLER *)irq_arg;

    uint8_t intSrc, intType;

    bool setError = false;

    volatile uint32_t timeoutCntr = 0;

    // Read all of the pending interrupts
    while ((intSrc = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_INTSRC, AD2425W_SIMPLE_MASTER_ACCESS))) {
        intType = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_INTTYPE, AD2425W_SIMPLE_MASTER_ACCESS);

        // Master running
        if (intType == 255) {
            ad2425w->masterRunning = true;
        }

        // Node discovered
        else if (intType == 24) {
            ad2425w->nodeDiscovered = true;
        }

        // Non-localized short to ground
        else if (intType == 41) {
            setError = true;
        }

        // Non-localized short to VBAT
        else if (intType == 42) {
            setError = true;
        }

        // Save the interrupt into our interrupt history array for debug purposes
        ad2425w->int_hist[ad2425w->int_ptr++] = (intSrc << 8) | intType;
        if (ad2425w->int_ptr >= 16) ad2425w->int_ptr = 0;

        if (timeoutCntr++ > 100) {
            return AD2425W_A2B_BUS_TIMEOUT;
        }
    }

    if (setError) {
        return AD2425W_A2B_BUS_ERROR;
    }

    return AD2425W_SIMPLE_SUCCESS;
}

/**
 * @brief      Initializes the a2b controller (AD2425W)
 *
 * @param      ad2425w      Pointer to instance structure
 * @param[in]  mode         specify if this device is a master or slave
 * @param[in]  twi_address  The twi address (master) for the ad2425w
 * @param[in]  device_num   The TWI/I2C peripheral to use (0, 1 or 2)
 *
 * @return     Success or failure
 */
BM_AD2425W_RESULT ad2425w_initialize(BM_AD2425W_CONTROLLER *ad2425w,
                                     BM_AD2425W_MODE mode,
                                     uint8_t twi_address,
                                     BM_TWI_PERIPHERAL_NUMBER device_num){

    // Ensure that the I2C/TWI address is even
    if (twi_address & 0x1) {
        // If not, return an error
        return AD2425W_SIMPLE_ODD_I2C_ADDRESS_ERROR;
    }

    // Set master and slave access addresses
    ad2425w->_twi_master_addr = twi_address;
    ad2425w->_twi_slave_addr = twi_address + 1;

    // Set mode of operation (Master or Slave)
    ad2425w->_mode = mode;

    // Set up the simple TWI driver to communicate with
    if (twi_initialize(&ad2425w->twi,
                       twi_address,
                       TWI_TYPICAL_SCLK0_FREQ,
                       device_num) != TWI_SIMPLE_SUCCESS) {

        return AD2425W_SIMPLE_ERROR;
    }

    // Initialize status variables
    ad2425w->nodeDiscovered = false;
    ad2425w->masterRunning = false;

    return AD2425W_SIMPLE_SUCCESS;
}

/**
 * @brief      Initializes the A2B system using a "commandlist" file from sigmastudio
 *
 * @param      ad2425w                   Pointer to instance structure
 * @param      init_Sequence             The initialize sequence
 * @param[in]  init_len                  The size of entire initialization sequence in bytes (not lines)
 * @param[in]  callback_remoteAudioInit  The callback remote for I2C initialize
 *
 * @return     Success or failure
 */

BM_AD2425W_RESULT ad2425w_load_init_sequence(BM_AD2425W_CONTROLLER *ad2425w,
                                             void *init_sequence,
                                             uint32_t init_len,
                                             void (*callback_remote_i2c_init)(BM_AD2425W_CONTROLLER *, uint8_t,  uint8_t),
                                             bool peripheral_init_included) {

    int i;
    BM_AD2425W_ACCESS_TYPE mode;
    uint8_t *a2bconfig = (uint8_t *)init_sequence;

    // The current slave node that we're talking to
    uint8_t currentSlaveNodeAddr = 0;

    // The current I2C peripheral address of a peripheral we're communicating with on a slave node
    uint8_t slavePeripheralI2CAddr = 0;

    BM_AD2425W_RESULT result;

    // Variables we'll read from the init file generated by SigmaStudio
    uint8_t i2c_addr, cmd, reg, val;
    uint8_t addr_width = 0;
    uint32_t addr = 0;
    uint32_t config_data_addr;
    uint8_t data_width, *config_data = NULL;
    uint16_t data_count = 0;

    uint8_t row_increment;
    if (peripheral_init_included) {
        // If we're using an init file with peripheral data, there is more data on each row
        row_increment = 16;
    }
    else {
        row_increment = 4;
    }

    uint16_t row_number = 0;
    for (i = 0; i < init_len; i += row_increment) {

        // Gather command parameters
        /**
         * When using the peripheral initialization mode, a larger structure is used
         */
        if (peripheral_init_included) {
            i2c_addr            = (*a2bconfig++);
            cmd                 = (*a2bconfig++);
            addr_width          = (*a2bconfig++);
            a2bconfig++; // Extra byte
            addr                = (*a2bconfig++);
            addr               |= ((*a2bconfig++) << 8);
            addr               |= ((*a2bconfig++) << 16);
            addr               |= ((*a2bconfig++) << 24);
            data_width          = (*a2bconfig++);
            a2bconfig++; // Extra byte
            data_count          = (*a2bconfig++);
            data_count         |= ((*a2bconfig++) << 8);
            config_data_addr    = (*a2bconfig++);
            config_data_addr   |= ((*a2bconfig++) << 8);
            config_data_addr   |= ((*a2bconfig++) << 16);
            config_data_addr   |= ((*a2bconfig++) << 24);

            config_data = (uint8_t *)config_data_addr;
            reg = 0xFF;
            val = *config_data;

            // Presently this driver only support init using byte-wide data streams
            if (data_width > 1) {
                return AD2425W_UNSUPPORTED_DATA_WIDTH;
            }
        }
        else {

            i2c_addr =  (*a2bconfig++);
            cmd =       (*a2bconfig++);
            reg =       (*a2bconfig++);
            val =       (*a2bconfig++);
        }

        // Check to see if this access is to the master or slave I2C address
        if      (i2c_addr == ad2425w->_twi_master_addr) mode = AD2425W_SIMPLE_MASTER_ACCESS;
        else if (i2c_addr == ad2425w->_twi_slave_addr) mode = AD2425W_SIMPLE_SLAVE_ACCESS;
        else {
            // If peripheral init commands are included in our init file, we'll be initializing things other than the A2B controller over I2C
            if (!peripheral_init_included) {
                // If we're not using peripheral init and we come across an illegal i2c address, return an error
                return AD2425W_CORRUPT_INIT_FILE;
            }
            else {
                // For now, don't initialize local components this way
                continue;
            }
        }

        //*********************************************************************
        // Write command
        //*********************************************************************
        if (cmd == A2B_WRITE) {

            if (peripheral_init_included) {
                if (data_count == 1 && addr_width == 1) {
                    ad2425w_write_ctrl_reg(ad2425w, (uint8_t)(addr & 0xFF), *config_data, mode);
                }
                else {
                    ad2425w_write_ctrl_reg_block(ad2425w,
                                                 addr,
                                                 addr_width,
                                                 data_count,
                                                 config_data,
                                                 mode);
                }
            }
            else {
                ad2425w_write_ctrl_reg(ad2425w, reg, val, mode);
            }

            //*********************************************************************
            // Read command
            //*********************************************************************
        }
        else if (cmd == A2B_READ) {

            // Init files typically only do 8-bit reads to and from teh AD2425W, not remote peripherals
            if (peripheral_init_included) {
                if (addr_width == 1) {
                    reg = (uint8_t)(addr & 0xFF);
                }
                else {
                    return AD2425W_UNSUPPORTED_READ_WIDTH;
                }
            }
            uint8_t read_val = ad2425w_read_ctrl_reg(ad2425w, reg, mode);

            // Handle values we've read back from the ad2425w
            if (reg == AD2425W_REG_INTPND2) {

                volatile uint32_t timeoutTimer = 0;

                // Wait until we see the node discovered interrupt
                while (!ad2425w->nodeDiscovered) {

                    // Check if interrupt is pending and handle it
                    if (ad2425w_interrupt_pending_check(ad2425w)) {
                        if ((result = ad2425w_irq_callback(ad2425w)) != AD2425W_SIMPLE_SUCCESS) return result;
                    }

                    // Handle timeout
                    if (timeoutTimer++ > 20000) {
                        return AD2425W_A2B_BUS_TIMEOUT;
                    }
                }
            }

            // Save vendor information for this node
            else if (reg == AD2425W_REG_VENDOR) {
                ad2425w->nodes[currentSlaveNodeAddr].vendor  = read_val;
            }

            // save product information for this node
            else if (reg == AD2425W_REG_PRODUCT) {
                ad2425w->nodes[currentSlaveNodeAddr].product = read_val;
            }

            // save version information for this node
            else if (reg == AD2425W_REG_VERSION) {
                ad2425w->nodes[currentSlaveNodeAddr].version = read_val;
            }

            //*********************************************************************
            // Delay command
            //*********************************************************************
        }
        else if (cmd == A2B_DELAY) {

            // If we're at the front of the init file, wait until we get our PLL synced interrupt and carry on
            if (row_number == 1) {
                while (!ad2425w->masterRunning) {

                    // Check if interrupt is pending and handle it
                    if (ad2425w_interrupt_pending_check(ad2425w)) {
                        if ((result = ad2425w_irq_callback(ad2425w)) != AD2425W_SIMPLE_SUCCESS) return result;
                    }
                }
            }
            else {

                // If our delay value is a multibyte value (e.g. ADAU1761), use the second byte value
                if (peripheral_init_included) {
                    if (data_count == 2) {
                        val = config_data[1];
                    }
                }
                volatile int x = 0;
                uint32_t delay_cnt = val * 35000;
                while (delay_cnt--) x += 1;
            }
        }

        /*
         * Check to see if we are changing the slave node address here or defining a i2c address on that slave
         */
        if (mode == AD2425W_SIMPLE_MASTER_ACCESS &&
            cmd == A2B_WRITE &&
            reg == AD2425W_REG_NODEADDR) {

            // Node address is in the 3 LSBs of the NODADDR register
            currentSlaveNodeAddr = val & 0x7;
        }
        if (mode == AD2425W_SIMPLE_SLAVE_ACCESS &&
            cmd == A2B_WRITE &&
            reg == AD2425W_REG_CHIP) {

            // Read the I2C chip address for this slave device
            slavePeripheralI2CAddr = val;
        }

        /*
         * Check to see if it's time to call our callback.  We're looking for the point
         * in the init code where we set the PERI bit to prepare to initialize an I2C device
         * over A2B.
         *
         */
        if (mode == AD2425W_SIMPLE_MASTER_ACCESS &&
            cmd == A2B_WRITE &&
            reg == AD2425W_REG_NODEADDR &&
            (val & 0x20)) {
            // Only do this if a callback function has been provided
            if (callback_remote_i2c_init) {

                /*
                 * If the peripheral initialization commands aren't included in this
                 * command sequence, call our call back and pass along the node we're talking to and the
                 * I2C address of the I2C device we're about to initialize
                 */
                if (!peripheral_init_included) {
                    callback_remote_i2c_init(ad2425w, currentSlaveNodeAddr, slavePeripheralI2CAddr);
                }
            }
        }

        row_number++;
    }

    return AD2425W_SIMPLE_SUCCESS;
}

/**
 * @brief      Creates a GPIO over distance (GPIOOD) port
 *
 * @param      ad2425w       The instance of the driver
 * @param[in]  master_pin    The pin on the master node
 * @param[in]  slave_pin     The pin on the slave node
 * @param[in]  slave_number  The slave number (id)
 * @param[in]  virtual_port  The virtual port
 * @param[in]  direction     The direction
 *
 * @return     success or failure
 */
BM_AD2425W_RESULT ad2425w_create_gpiood_port(BM_AD2425W_CONTROLLER *ad2425w,
                                             BM_A2B_GPIO_PIN master_pin,
                                             BM_A2B_GPIO_PIN slave_pin,
                                             uint8_t slave_number,
                                             BM_A2B_GPIO_VIRT_PORT virtual_port,
                                             BM_A2B_GPIO_DIR direction) {

    uint8_t master_gpio_register  = 0x81 + (uint8_t)master_pin;
    uint8_t slave_gpio_register   = 0x81 + (uint8_t)slave_pin;
    uint8_t master_gpio_bit_field = 1 << (uint8_t)master_pin;
    uint8_t slave_gpio_bit_field  = 1 << (uint8_t)slave_pin;
    uint8_t virtual_port_field    = 1 << (uint8_t)virtual_port;

    uint8_t regval;

    // Set the node address for this slave
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_NODEADDR, slave_number, AD2425W_SIMPLE_MASTER_ACCESS);

    if (direction == A2B_GPIO_MASTER_TO_SLAVE) {

        // 1. Write to master node register to map pin on master AD2425 to virtual port (slave pin)
        ad2425w_write_ctrl_reg(ad2425w, master_gpio_register, virtual_port_field, AD2425W_SIMPLE_MASTER_ACCESS);

        // 2. Enable GPIO Over Distance for the master pin
        regval = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, AD2425W_SIMPLE_MASTER_ACCESS);
        ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, regval | master_gpio_bit_field, AD2425W_SIMPLE_MASTER_ACCESS);

        // 3. Enable GPIO output for this pin on the slave node
        regval = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_GPIOOEN, AD2425W_SIMPLE_SLAVE_ACCESS);
        ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_GPIOOEN, regval | slave_gpio_bit_field, AD2425W_SIMPLE_SLAVE_ACCESS);

        // 4. Enable GPIO output for this pin on the slave node
        ad2425w_write_ctrl_reg(ad2425w, slave_gpio_register, virtual_port_field, AD2425W_SIMPLE_SLAVE_ACCESS);

        // 5. Enable GPIO Over Distance for the slave pin
        regval = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, AD2425W_SIMPLE_SLAVE_ACCESS);
        ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, regval | slave_gpio_bit_field, AD2425W_SIMPLE_SLAVE_ACCESS);
    }

    else if (direction == A2B_GPIO_SLAVE_TO_MASTER) {

        // 1. Enable GPIO output for this pin on the slave node
        ad2425w_write_ctrl_reg(ad2425w, slave_gpio_register, virtual_port_field, AD2425W_SIMPLE_SLAVE_ACCESS);

        // 2. Enable GPIO Over Distance for the slave pin
        regval = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, AD2425W_SIMPLE_SLAVE_ACCESS);
        ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, regval | slave_gpio_bit_field, AD2425W_SIMPLE_SLAVE_ACCESS);

        // 3. Enable GPIO output for this master IO pin
        regval = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_GPIOOEN, AD2425W_SIMPLE_MASTER_ACCESS);
        ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_GPIOOEN, regval | master_gpio_bit_field, AD2425W_SIMPLE_MASTER_ACCESS);

        // 4.  Write to master node register to map pin on master AD2425 to virtual port
        ad2425w_write_ctrl_reg(ad2425w, master_gpio_register, virtual_port_field, AD2425W_SIMPLE_MASTER_ACCESS);

        // 5. Enable GPIO Over Distance for the master pin
        regval = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, AD2425W_SIMPLE_MASTER_ACCESS);
        ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_GPIODEN, regval | master_gpio_bit_field, AD2425W_SIMPLE_MASTER_ACCESS);
    }

    return AD2425W_SIMPLE_SUCCESS;
}

/**
 * @brief      Sets up A2B bus for an I2C access on a slave node
 *
 * @param      ad2425w    The instance of the driver
 * @param[in]  slaveNode  The slave node address
 * @param[in]  i2caddr    I 2 caddr
 */
void ad2425w_select_slave_i2c_node(BM_AD2425W_CONTROLLER *ad2425w,
                                   uint8_t slaveNode,
                                   uint8_t i2caddr){
    // Set the node address
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_NODEADDR, slaveNode, AD2425W_SIMPLE_MASTER_ACCESS);

    // Set the I2C chip address on that slave node
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_CHIP, i2caddr, AD2425W_SIMPLE_SLAVE_ACCESS);

    // Enable the PERI bit
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_NODEADDR, 0x20 | slaveNode, AD2425W_SIMPLE_MASTER_ACCESS);
}

/**
 * @brief      Selects the slave node to configure a slave controller
 *
 * @param      ad2425w    The instance of the driver
 * @param[in]  slaveNode  The slave node address
 * @param[in]  i2caddr    I 2 caddr
 */
void ad2425w_select_slave_node(BM_AD2425W_CONTROLLER *ad2425w,
                               uint8_t slaveNode){
    // Set the node address
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_NODEADDR, slaveNode, AD2425W_SIMPLE_MASTER_ACCESS);
}

/**
 * @brief      Completes/de-selects slave A2B I2C access
 *
 * @param      ad2425w    The instance of the driver
 */
void ad2425w_deselect_slave_i2c_node(BM_AD2425W_CONTROLLER *ad2425w) {

    // Set the node address
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_NODEADDR, 0x0, AD2425W_SIMPLE_MASTER_ACCESS);

    // Clear the I2C chip address on that slave node
    ad2425w_write_ctrl_reg(ad2425w, AD2425W_REG_CHIP, 0x0, AD2425W_SIMPLE_MASTER_ACCESS);
}

/**
 * @brief      Polls the AD2425W chip to see if an I2C interrupt is pending
 *
 * @param      ad2425w  The instance of the driver
 *
 * @return     True if interrupt is pending, false if not
 */
bool ad2425w_interrupt_pending_check(BM_AD2425W_CONTROLLER *ad2425w) {

    uint8_t read_val = ad2425w_read_ctrl_reg(ad2425w, AD2425W_REG_INTSTAT, AD2425W_SIMPLE_MASTER_ACCESS);

    // If the IRQ bit is set, return true
    if (read_val) {
        return true;
    }
    else {
        return false;
    }
}

/**
 * @brief      Writes a control register in the AD2425W
 *
 * @param      ad2425w  The instance of the driver
 * @param[in]  reg      The register address
 * @param[in]  value    The value
 * @param[in]  mode     access mode (master or slave)
 */
void ad2425w_write_ctrl_reg(BM_AD2425W_CONTROLLER *ad2425w, uint8_t reg, uint8_t value, BM_AD2425W_ACCESS_TYPE mode) {

    // Set a temporary I2C address for slave access
    if (mode == AD2425W_SIMPLE_SLAVE_ACCESS) {
        twi_set_temporary_address(&ad2425w->twi, ad2425w->_twi_slave_addr);
    }

    // Perform write
    uint8_t seq[2] = {reg, value};
    twi_write_block(&ad2425w->twi, seq, 2);

    // Fall back to original master address
    if (mode == AD2425W_SIMPLE_SLAVE_ACCESS) {
        twi_restore_address(&ad2425w->twi);
    }
}

/**
 * @brief      Writes a block of data to the AD2425W.  This is used primarily to initialize remote A2B nodes
 *
 * @param      ad2425w     The instance of the driver
 * @param[in]  addr        The address of the I2C control register to write in the remote note
 * @param[in]  addr_bytes  The number of bytes in the address
 * @param[in]  len         The total number of bytes to write
 * @param      values      The values to be written
 * @param[in]  mode        The mode (master or slave access)
 */
void ad2425w_write_ctrl_reg_block(BM_AD2425W_CONTROLLER *ad2425w,
                                  uint32_t addr,
                                  uint8_t addr_bytes,
                                  uint16_t len,
                                  uint8_t *values,
                                  BM_AD2425W_ACCESS_TYPE mode) {

    // Set a temporary I2C address for slave access
    if (mode == AD2425W_SIMPLE_SLAVE_ACCESS) {
        twi_set_temporary_address(&ad2425w->twi, ad2425w->_twi_slave_addr);
    }

    // Get address ready to transmit - send MSB first
    uint8_t seq[4];
    if (addr_bytes == 1) {
        seq[0] = addr & 0xFF;
    }
    else if (addr_bytes == 2) {
        seq[0] = ((addr >> 8) & 0xFF);
        seq[1] = addr & 0xFF;
    }
    if (addr_bytes == 4) {
        seq[0] = ((addr >> 24) & 0xFF);
        seq[1] = ((addr >> 16) & 0xFF);
        seq[2] = ((addr >> 8) & 0xFF);
        seq[3] = addr & 0xFF;
    }

    // Write address followed by block of data
    twi_write_block_r(&ad2425w->twi, seq, addr_bytes, true);
    twi_write_block(&ad2425w->twi, values, len);

    // Fall back to original master address
    if (mode == AD2425W_SIMPLE_SLAVE_ACCESS) {
        twi_restore_address(&ad2425w->twi);
    }
}

/**
 * @brief      Reads a control register in the AD2425W
 *
 * @param      ad2425w  The instance of the driver
 * @param[in]  reg      The register address
 * @param[in]  mode     access mode (master or slave)
 *
 * @return     { description_of_the_return_value }
 */
uint8_t ad2425w_read_ctrl_reg(BM_AD2425W_CONTROLLER *ad2425w, uint8_t reg, BM_AD2425W_ACCESS_TYPE mode) {

    // Set a temporary I2C address for slave access
    if (mode == AD2425W_SIMPLE_SLAVE_ACCESS) {
        twi_set_temporary_address(&ad2425w->twi, ad2425w->_twi_slave_addr);
    }

    twi_write_r(&ad2425w->twi, reg, true);
    uint8_t val;
    twi_read(&ad2425w->twi, &val);

    // Fall back to original master address
    if (mode == AD2425W_SIMPLE_SLAVE_ACCESS) {
        twi_restore_address(&ad2425w->twi);
    }

    return val;
}
