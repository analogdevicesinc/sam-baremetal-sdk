/*
 * Copyright (c) 2018 Analog Devices, Inc.  All rights reserved.
 *
 * Bare-Metal ("BM") device driver header for A2B
 */
#ifndef _BM_AD2425W_H
#define _BM_AD2425W_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include "drivers/bm_gpio_driver/bm_gpio.h"
#include "drivers/bm_twi_driver/bm_twi.h"

// Used to read A2BConfig files generated by SigmaStudio
#define     A2B_WRITE   ((unsigned char)0x00u)
#define     A2B_READ    ((unsigned char)0x01u)
#define     A2B_DELAY   ((unsigned char)0x02u)
#define     A2B_INVALID ((unsigned char)0xffu)

#define     A2B_MAX_NODES   (8)

#define     AD2425W_REG_CHIP                    0x00
#define     AD2425W_REG_NODEADDR                0x01
#define     AD2425W_REG_VENDOR                  0x02
#define     AD2425W_REG_PRODUCT                 0x03
#define     AD2425W_REG_VERSION                 0x04
#define     AD2425W_REG_CAPABILITY              0x05

#define     AD2425W_REG_SWCTL                   0x09
#define     AD2425W_REG_BCDNSLOTS               0x0A
#define     AD2425W_REG_LDNSLOTS                0x0B
#define     AD2425W_REG_LUPSLOTS                0x0C
#define     AD2425W_REG_DNSLOTS                 0x0D
#define     AD2425W_REG_UPSLOTS                 0x0E
#define     AD2425W_REG_RESPCYCS                0x0F
#define     AD2425W_REG_SLOTFMT                 0x10

#define     AD2425W_REG_DATCTL                  0x11
#define     AD2425W_REG_CONTROL                 0x12
#define     AD2425W_REG_DISCVRY                 0x13

#define     AD2425W_REG_SWSTAT                  0x14
#define     AD2425W_REG_INTSTAT                 0x15
#define     AD2425W_REG_INTSRC                  0x16
#define     AD2425W_REG_INTTYPE                 0x17
#define     AD2425W_REG_INTPND0                 0x18
#define     AD2425W_REG_INTPND1                 0x19
#define     AD2425W_REG_INTPND2                 0x1A
#define     AD2425W_REG_INTMSK0                 0x1B
#define     AD2425W_REG_INTMSK1                 0x1C
#define     AD2425W_REG_INTMSK2                 0x1D

#define     AD2425W_REG_BECCTL                  0x1E
#define     AD2425W_REG_BECCNT                  0x1F
#define     AD2425W_REG_TESTMODE                0x20
#define     AD2425W_REG_ERRCNT0                 0x21
#define     AD2425W_REG_ERRCNT1                 0x22
#define     AD2425W_REG_ERRCNT2                 0x23
#define     AD2425W_REG_ERRCNT3                 0x24

#define     AD2425W_REG_NODE                    0x29
#define     AD2425W_REG_DISCSTAT                0x2B
#define     AD2425W_REG_LINTTYPE                0x3E

#define     AD2425W_REG_I2CCFG                  0x3F
#define     AD2425W_REG_PLLCTL                  0x40
#define     AD2425W_REG_I2SGCFG                 0x41
#define     AD2425W_REG_I2SCFG                  0x42
#define     AD2425W_REG_I2SRATE                 0x43
#define     AD2425W_REG_I2STXOFFSET             0x44
#define     AD2425W_REG_I2SRXOFFSET             0x45
#define     AD2425W_REG_SYNCOFFSET              0x46
#define     AD2425W_REG_PDMCTL                  0x47

#define     AD2425W_REG_ERRMGMT                 0x48
#define     AD2425W_REG_CLKCFG                  0x49

#define     AD2425W_REG_GPIODAT                 0x4A
#define     AD2425W_REG_GPIODATSET              0x4B
#define     AD2425W_REG_GPIODATCLR              0x4C
#define     AD2425W_REG_GPIOOEN                 0x4D
#define     AD2425W_REG_GPIOIEN                 0x4E
#define     AD2425W_REG_GPIOIN                  0x4F

#define     AD2425W_REG_PINTEN                  0x50
#define     AD2425W_REG_PINTINV                 0x51
#define     AD2425W_REG_PINCFG                  0x52
#define     AD2425W_REG_I2STEST                 0x53
#define     AD2425W_REG_RAISE                   0x54
#define     AD2425W_REG_GENERR                  0x55
#define     AD2425W_REG_I2SRRATE                0x56
#define     AD2425W_REG_I2SRRCTL                0x57
#define     AD2425W_REG_I2SRROFFS               0x58
#define     AD2425W_REG_CLK1CFG                 0x59
#define     AD2425W_REG_CLK2CFG                 0x5A
#define     AD2425W_REG_BMMCFG                  0x5B
#define     AD2425W_REG_SUSCFG                  0x5C
#define     AD2425W_REG_UPMASK0                 0x60
#define     AD2425W_REG_UPMASK1                 0x61
#define     AD2425W_REG_UPMASK2                 0x62
#define     AD2425W_REG_UPMASK3                 0x63
#define     AD2425W_REG_UPOFFSET                0x64
#define     AD2425W_REG_DNMASK0                 0x65
#define     AD2425W_REG_DNMASK1                 0x66
#define     AD2425W_REG_DNMASK2                 0x67
#define     AD2425W_REG_DNMASK3                 0x68
#define     AD2425W_REG_DNOFFSET                0x69

/*GPIO Registers */

#define     AD2425W_REG_GPIODEN                 0x80
#define     AD2425W_REG_GPIOD0MSK               0x81
#define     AD2425W_REG_GPIOD1MSK               0x82
#define     AD2425W_REG_GPIOD2MSK               0x83
#define     AD2425W_REG_GPIOD3MSK               0x84
#define     AD2425W_REG_GPIOD4MSK               0x85
#define     AD2425W_REG_GPIOD5MSK               0x86
#define     AD2425W_REG_GPIOD6MSK               0x87
#define     AD2425W_REG_GPIOD7MSK               0x88
#define     AD2425W_REG_GPIODDAT                0x89
#define     AD2425W_REG_GPIODINV                0x8A

/*Mailbox Registers */

#define     AD2425W_REG_MBOX0_CTL               0x90
#define     AD2425W_REG_MBOX0_STAT              0x91
#define     AD2425W_REG_MBOX0_BYTE0             0x92
#define     AD2425W_REG_MBOX0_BYTE1             0x93
#define     AD2425W_REG_MBOX0_BYTE2             0x94
#define     AD2425W_REG_MBOX0_BYTE3             0x95

#define     AD2425W_REG_MBOX1_CTL               0x96
#define     AD2425W_REG_MBOX1_STAT              0x97
#define     AD2425W_REG_MBOX1_BYTE0             0x98
#define     AD2425W_REG_MBOX1_BYTE1             0x99
#define     AD2425W_REG_MBOX1_BYTE2             0x9A
#define     AD2425W_REG_MBOX1_BYTE3             0x9B

// GPIO pins connected to the AD2425W on the SHARC Audio Module board
#define     GPIO_SHARC_SAM_AD2425_IRQ           BM_GPIO_PORTPIN_MAKE(ADI_GPIO_PORT_F, 07)
#define     GPIO_SHARC_SAM_AD2425_MSTR          BM_GPIO_PORTPIN_MAKE(ADI_GPIO_PORT_F, 13)

// Base address for AD2425W (A2B controller)
#define     AD2425W_SAM_I2C_ADDR                0x68
#define     AD2425W_SAM_AUTO_I2C_ADDR           0x6A

typedef enum
{
    AD2425W_SIMPLE_MASTER,                  // Master mode
    AD2425W_SIMPLE_SLAVE                    // Slave mode
} BM_AD2425W_MODE;

typedef enum
{
    A2B_GPIO_PIN_0,                 // IO Pin 0
    A2B_GPIO_PIN_1,                 // IO Pin 1
    A2B_GPIO_PIN_2,                 // IO Pin 2
    A2B_GPIO_PIN_3,                 // IO Pin 3
    A2B_GPIO_PIN_4,                 // IO Pin 4
    A2B_GPIO_PIN_5,                 // IO Pin 5
    A2B_GPIO_PIN_6,                 // IO Pin 6
    A2B_GPIO_PIN_7                  // IO Pin 7
} BM_A2B_GPIO_PIN;

typedef enum
{
    A2B_GPIO_VIRT_PORT_0,                   // IO Virtual Port 0
    A2B_GPIO_VIRT_PORT_1,                   // IO Virtual Port 1
    A2B_GPIO_VIRT_PORT_2,                   // IO Virtual Port 2
    A2B_GPIO_VIRT_PORT_3,                   // IO Virtual Port 3
    A2B_GPIO_VIRT_PORT_4,                   // IO Virtual Port 4
    A2B_GPIO_VIRT_PORT_5,                   // IO Virtual Port 5
    A2B_GPIO_VIRT_PORT_6,                   // IO Virtual Port 6
    A2B_GPIO_VIRT_PORT_7                // IO Virtual Port 7
} BM_A2B_GPIO_VIRT_PORT;

typedef enum
{
    A2B_GPIO_MASTER_TO_SLAVE,       // Master to slave pin
    A2B_GPIO_SLAVE_TO_MASTER        // Slave to master pin
} BM_A2B_GPIO_DIR;

typedef enum
{
    AD2425W_SIMPLE_SUCCESS,                 // The API call is success
    AD2425W_A2B_BUS_ERROR,                  // A bus error was encountered while initializing the bus
    AD2425W_A2B_BUS_TIMEOUT,                // A timeout occurred while initializing the bus
    AD2425W_SIMPLE_GPIO_SVCS_ERROR,         // Error initializing the GPIO service
    AD2425W_SIMPLE_INVALID_GPIO,            // Invalid GPIO used with A2B
    AD2425W_SIMPLE_ODD_I2C_ADDRESS_ERROR,   // I2C address needs to be even
    AD2425W_CORRUPT_INIT_FILE,              // SS Generated Init file is corrupt
    AD2425W_UNSUPPORTED_READ_WIDTH,         // An init file has a multibyte read command which isn't yet implemented in this driver
    AD2425W_UNSUPPORTED_DATA_WIDTH,         // An init file has a multibyte data format which isn't yet implemented in this driver
    AD2425W_SIMPLE_ERROR                    // General failure
} BM_AD2425W_RESULT;

typedef enum
{
    AD2425W_SIMPLE_MASTER_ACCESS,
    AD2425W_SIMPLE_SLAVE_ACCESS
} BM_AD2425W_ACCESS_TYPE;

typedef struct
{
    uint8_t vendor;
    uint8_t product;
    uint8_t version;
} BM_AD2425W_A2B_BUS_NODE;

typedef struct
{
    BM_TWI twi;                         // Simple TWI driver
    uint8_t _twi_master_addr;                   // Master address of A2B controller
    uint8_t _twi_slave_addr;                    // Slave address of A2B controller

    BM_AD2425W_MODE _mode;

    // Whether or not the A2B init file from SS includes remote peripheral initialization
    bool peripheral_init;

    // Registers
    uint8_t reg_intpnd2;

    uint16_t int_hist[16];
    uint8_t int_ptr;

    // Hardware connections
    BM_GPIO_PORTPIN _irq_pin;

    // Events
    bool nodeDiscovered;
    bool masterRunning;

    // Information on nodes
    BM_AD2425W_A2B_BUS_NODE nodes[A2B_MAX_NODES];
} BM_AD2425W_CONTROLLER;

#ifdef __cplusplus
extern "C" {
#endif

// Initializes the a2b controller (AD2425W)
BM_AD2425W_RESULT ad2425w_initialize(BM_AD2425W_CONTROLLER *ad2425w,
                                     BM_AD2425W_MODE mode,
                                     uint8_t twi_address,
                                     BM_TWI_PERIPHERAL_NUMBER device_num);

// Initializes the A2B system using a "commandlist" file from sigmastudio
BM_AD2425W_RESULT ad2425w_load_init_sequence(BM_AD2425W_CONTROLLER *ad2425w,
                                             void *init_Sequence,
                                             uint32_t init_len,
                                             void (*callback_remoteAudioInit)(BM_AD2425W_CONTROLLER *, uint8_t,  uint8_t),
                                             bool peripheral_init_included);

// Sets up a virtual gpio over distance port between master and a slave
BM_AD2425W_RESULT ad2425w_create_gpiood_port(BM_AD2425W_CONTROLLER *ad2425w,
                                             BM_A2B_GPIO_PIN master_pin,
                                             BM_A2B_GPIO_PIN slave_pin,
                                             uint8_t slave_number,
                                             BM_A2B_GPIO_VIRT_PORT virtual_port,
                                             BM_A2B_GPIO_DIR direction);

// Writes a control register in the AD2425W
void ad2425w_write_ctrl_reg(BM_AD2425W_CONTROLLER *ad2425w,
                            uint8_t reg,
                            uint8_t value,
                            BM_AD2425W_ACCESS_TYPE mode);

// Writes a block of data to the AD2425W - used to initialize remote I2C devices
void ad2425w_write_ctrl_reg_block(BM_AD2425W_CONTROLLER *ad2425w,
                                  uint32_t addr,
                                  uint8_t addr_bytes,
                                  uint16_t len,
                                  uint8_t *values,
                                  BM_AD2425W_ACCESS_TYPE mode);

// Reads a control register in the AD2425W
uint8_t ad2425w_read_ctrl_reg(BM_AD2425W_CONTROLLER *ad2425w,
                              uint8_t reg,
                              BM_AD2425W_ACCESS_TYPE mode);

// Sets up A2B bus for an I2C access on a slave node
void ad2425w_select_slave_i2c_node(BM_AD2425W_CONTROLLER *ad2425w,
                                   uint8_t slaveNode,
                                   uint8_t i2caddr);

// Selects a slave node without setting a slave I2C address - useful if we just want to configure the slave node ctrl register
void ad2425w_select_slave_node(BM_AD2425W_CONTROLLER *ad2425w,
                               uint8_t slaveNode);

// Completes/de-selects slave A2B node (these two functions do the same thing)
void ad2425w_deselect_slave_i2c_node(BM_AD2425W_CONTROLLER *ad2425w);
void ad2425w_deselect_slave_node(BM_AD2425W_CONTROLLER *ad2425w);

// Checks to see if an interrupt is pending within the AD2425
bool ad2425w_interrupt_pending_check(BM_AD2425W_CONTROLLER *ad2425w);

#ifdef __cplusplus
} // extern "C"
#endif

#endif  //_BM_AD2425W_H
